\chapter{Analýza}
%% TODO: zde napsat prehledovy text o tom, co vsechno tato kapitola obsahuje

\section{Problematika návrhu software}
Při návrhu software se uplatňují nejrůznější přístupy, vzory, pravidla. Cílem této sekce je podat rychlý přehled o používaných návrhových konceptech, aspektech návrhu software a objektově orientovaném návrhu. U některých aspektů uvažujeme možnost jejich podpory pomocí vhodného nástroje. Mnoho z uvedených pojmů a postupů je dále použito při návrhu nástroje, jehož vytvoření je jedním z cílů této práce.

\subsection{Koncepty používané při návrhu software}
Existující koncepty návrhu software poskytují vývojářům základ, z~něhož lze odvodit a aplikovat další sofistikované metody \cite{wiki:software_design}. Většinou se jedná o různé pohledy na způsob dekompozice systému na části realizovatelné v konkrétním programovacím jazyce. Postupem času se vyvinula celá množina konceptů návrhu software \cite{swengineeringconcepts}. Uveďme alespoň některé:

\paragraph{Abstrakce (Abstraction)} Abstrakce je proces nebo výsledek zobecnění a redukce informačního obsahu konceptu nebo pozorovatelného jevu. Typicky ponecháváme pouze informaci, která je relevantní pro konkrétní účel nebo záměr.

\paragraph{Postupné zjemňování (Refinement)} Postupné zjemňování/zpřesňování představuje proces tvorby\footnote{Tento koncept byl použit i pro tvorbu této práce. Nejprve byla provedena dekompozice tématu na základní bloky (specifikace, analýza, návrh, \ldots) a poté byly \uv{rekurzivním sestupem} realizované další sekce, podsekce a nakonec i elementární součásti práce (odstavce a věty).}. Je vytvářena hierarchie dekompozicí makroskopických příkazů funkce po krocích, dokud nejsou dosaženy elementární příkazy programovacího jazyka. V každém kroku je dekomponována jedna nebo více instrukcí daného programu do detailnějších instrukcí. Abstrakce a zjemňování jsou vzájemně komplementární oblasti.

\paragraph{Modularita (Modularity)} Systém je rozdělen do samostatných komponent nazvaných moduly (popsáno dále v podsekci \ref{analysis-sw_design_aspects}).

\paragraph{Architektura (Software Architecture)} Tento pojem odkazuje na celkovou strukturu softwarového systému a způsoby, kterými tato struktura zajišťuje konceptuální ucelenost systému.

\paragraph{Hierarchie řízení (Control Hierarchy)} Struktura programu, která reprezentuje organizaci programových komponent a určuje hierarchii řízení. Tato struktura však nedefinuje přesné pořadí operací.

\paragraph{Strukturální dělení (Structural Partitioning)} Struktura programu může být definována jak v horizontálním, tak vertikálním smyslu. Horizontální dělení představuje samostatné větve hierarchie modulů pro hlavní funkčnosti programu. Vertikální dělení slouží k distribuci řízení a průběhu zpracování do jednotlivých úrovní (vysokoúrovňové rutiny a nízkoúrovňové operace).

\paragraph{Struktura dat (Data Structure)} Logická reprezentace vztahů mezi jednotlivými datovými elementy.

\paragraph{Softwarová procedura (Software Procedure)} Koncept \emph{softwarové procedury} se zaměřuje na průběh zpracovávání každého jednotlivého modulu. Narozdíl od konceptu \emph{hierarchie řízení}, který se zabývá pouze vztahy (která komponenta je řízena kterou komponentou), se zaměřuje na návrh přesné posloupnosti kroků, které modul provádí.

\paragraph{Zapouzdření (Information Hiding)} Moduly by měly být navrhovány tak, aby informace v nich obsažená byla nedostupná modulům, které tuto informaci nepotřebují.

\subsection{Aspekty návrhu software}
\label{analysis-sw_design_aspects}
Při návrhu software musíme vzít v~potaz velké množství aspektů \cite{wiki:software_design}. Důležitost přikladaná jednotlivým aspektům je odvozena od účelu, za nímž je software realizován. Pro některé systémy může být klíčové rozšiřitelnost, pro jiné stabilita. Mezi základní aspekty patří:

\begin{itemize}
\item \emph{kompatibilita (compatibility)},
\item \emph{rozšiřitelnost (extensibility)},
\item \emph{zotavení se z~chyb (fault-tolerance/graceful degradation)} \cite{wiki:fault-tolerance},
\item \emph{udržovatelnost (maintainability)},
\item \emph{modularita (modularity)},
\item \emph{balení (packaging)},
\item \emph{spolehlivost (reliability)},
\item \emph{znovupoužitelnost (reusability)},
\item \emph{stabilita (robustness)},
\item \emph{bezpečnost (security)},
\item \emph{použitelnost (usability)}.
\end{itemize}

Zatímco některé aspekty jsou pro tuto práci zcela nepodstatné (dobrým příkladem budiž \emph{balení}, které se zabývá způsobem dodávky software a podporných materiálů), jiné je možné podpořit pomocí vhodného nástroje. Pojďme se nyní podívat na aspekty, jejichž podpora možná je:

\paragraph{Rozšiřitelnost} Tato vlastnost znamená praktický důsledek, kdy nové funkčnosti mohou být do existujícího systému přidány bez majoritních změn ve \emph{výchozí architektuře}. Pokud by bylo možné určit pravidla, která určují základní architekturu a která je možné vynutit, bylo by možné při rozšiřování systému tato pravidla opět aplikovat, což by vedlo k~dodržení výchozí architektury.

\paragraph{Udržovatelnost} Klíčovou charakteristikou \emph{udržovatelnosti} je možnost obnovit stav systému v~rozumném čase. Příkladem mohou být aktualizace virové báze antivirových programů. Jiným příkladem může být instalace bezpečnostních aktualizací. Tuto vlastnost nelze podpořit zcela přímo, je však důsledkem ostatních vlastností (zejména \emph{rozšiřitelnost} a \emph{modularita}).

\paragraph{Modularita} \emph{Modularita} znamená, že výsledný systém sestává z~dobře definovaných a nezávislých komponent. To vede k~lepší \emph{udržovatelnosti}. Komponenty mohou být v~takovém případě vyvíjeny a testovány izolovaně předtím než jsou integrovány do výsledného požadovaného softwarového systému. Navíc získáme dobrou možnost dělby práce v~rámci vývojového týmu pracujícího na softwarovém projektu.

\paragraph{Znovupoužitelnost} Je důležité, aby bylo možné přidávat nové vlastnosti (features) systému a provádět modifikace s~pouze omezenou nebo žádnou modifikací existujících komponent (možnost použít komponenty znovu pro jiné případy užití).

\subsection{Objektově orientovaný návrh software}
Základním vstupem pro objektově orientovaný návrh bývá (mimo jiné) \emph{konceptuální model}, případně seznam \emph{případů užití} systému. To jsou výsledky předešlé fáze analýzy. Na základě těchto informací je poté zpravidla sestavován návrh systému, který pracuje nad dříve definovanými doménovými objekty.

Klíčovými pojmy při objektově orientovném návrhu jsou \cite{wiki:oop_design}:

\paragraph{Objekt/třída}  Objekt/třída představují těsné propojení mezi datovými strukturami a metodami/funkcemi, které nad těmito daty pracují. Každý objekt by měl sloužit samostatné funkci. Je definován svými atributy/vlastnostmi, tím co je a tím co může dělat.
\paragraph{Zapouzdření} Zapouzdření je schopnost chránit některé součásti objektu před externími entitami. To je zpravidla realizováno klíčovými slovy implementujícího programovacího jazyka, která umožňují deklarovat proměnnou jako privátní nebo chráněnou uvnitř vlastnické třídy.
\paragraph{Dědičnost} Dědičnost umožňuje nové třídě rozšířit nebo i přepsat funkcionalitu jiné třídy. Výsledná podtřída má kompletní část, která je derivována z nadtřídy a navíc své vlastní funkce a data.
\paragraph{Rozhraní} Rozhraní představuje možnost odložení implementace metod. Je možné definovat signatury funkcí nebo metod, aniž by bylo nutné tyto metody implementovat.
\paragraph{Polymorfismus} Polymorfismus nám umožňuje nahradit objekt jeho podobjektem (instancí podtřídy). Proměnná tedy může obsahovat buď objekt nebo kterýkoliv jeho podobjekt.

Při vlastním návrhu systému se používají principy objektového návrhu (popsáno dále v sekci \ref{analysis-oop_design_principles}) a návrhové vzory. Pro realizaci objektových systému se potom používají nejrůznější frameworky a knihovny.

\section{Analýza principů objektového návrhu}
\label{analysis-oop_design_principles}

Principy objektového nárhu reprezentují množinu pokynů, které nám pomáhají vyhnout se špatnému návrhu \cite{oop_design_principles}. Špatný návrh vykazuje zejména následující vlastnosti \cite{oop_design_principles_and_patterns}:

\begin{itemize}
\item \emph{Rigidity} -- je obtížné provést změnu v systému protože každá změna ovlivňuje příliš mnoho dalších částí systému,
\item \emph{Fragility} -- pokud provedete změnu, mohou přestat fungovat části systému u nichž se to nečeká,
\item \emph{Immobility} -- je obtížné znovupoužití části systému v jiné aplikaci, protože tato část nemůže být \uv{vymotána} z aktuální aplikace.
\end{itemize}

Autor výše zmíněného článku (\cite{oop_design_principles_and_patterns}) cituje zajímavé návrhové principy. Například \emph{Open Closed Principle}, který vyžaduje, aby se existující třídy a řešení nemodifikovaly, ale rozšiřovaly. Dalším principem je \emph{Liskov's substitution principle}, který vymezuje pravidla pro dědění tak, aby instance podtřídy mohla bezpečně vystupovat na místě své nadtřídy\footnote{Ve článku je rozebráno, jaké operace bychom neměli provádět v oddědědné třídě -- je totiž možné změnit chování odděděné třídy tak, že již nemůže bezpečně vystupovat na místě svého předka.}.

Důležité je srovnání \emph{návrhových principů} s \emph{návrhovými vzory}. Toto srovnání podává článek \cite{612257}. Zatímco aplikace návrhového vzoru představuje znovupoužití \uv{úspěšného} návrhu, princip představuje spíše obecně platné pravidlo, jehož dodržováním během návrhu bychom měli získat návrh přijatelné kvality. V případě přesného stanovení potřebných principů by bylo možné provádět automatizovný systematický návrh (což není, vzhledem k mnoha aspektům popisovaným v článku, dobře možné).

\subsection{Analyzované principy}
Na základě požadavků specifikovaných sekci \ref{requirements-principle_analysis} se budeme postupně zabývat principy \emph{low coupling}, \emph{high cohesion} a \emph{Law of Demeter}. Jedná se o~principy, které se týkají strukturální kvality kódu.

Ukázkové návrhové principy a vztahy mezi nimi jsou znázorněny na obrázku \ref{analyzed_principles}. Poznamenejme, že \emph{Law of Demeter} (dále budeme používat zkratku \emph{LoD}) je konkretizací požadavků na \emph{nízkou závislost} (\emph{low coupling}) mezi moduly.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\textwidth]{./graphs/oop_design_principles.png}
  \caption{Znázornění analyzovaných návrhových principů.\label{analyzed_principles}}
\end{figure}

\subsubsection{Low coupling/dependency (nízká závislost/vazba)}

%% * [[Measuring coupling and cohesion in object-oriented systems|http://www.isys.uni-klu.ac.at/PDF/1995-0043-MHBM.pdf]]
%% * [[Defining and validating high-level design metrics|http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.31.4744&rep=rep1&type=pdf]]
%% * [[Bieman, J.M.; Byung-Kyoo Kang; , "Measuring design-level cohesion," Software Engineering, IEEE Transactions on , vol.24, no.2, pp.111-124, Feb 1998|http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=666825&isnumber=14664]]

Závislost/vazba (coupling/dependency) mezi moduly softwarového projektu určuje, do jaké míry se jeden modul spoléhá na každý z~ostatních modulů \cite{wiki:coupling}. Zatímco některé moduly spolu vůbec nekomunikují (nemají žádnou závislost), jiné se spoléhají nejen na rozhraní ostatních modulů, ale mnohdy i na jejich vnitřní fungování, způsob reprezentace dat, časování atd. Důsledkem vyšší závislosti je potom nutnost rozsáhlých úprav v~mnoha modulech i při úpravě naprostých drobností v~jednom konkrétním modulu.

Proto je důležitou návrhovou zásadou snaha snížit provázanost modulů na minimum. Je zřejmé, že provázanost modulů vždy existuje (jinak by neměl modulární návrh smysl). Proto nelze striktně říci, do jaké míry smí/nesmí být moduly provázané.

V~\cite{wiki:coupling} a \cite{STVR:STVR162} (podrobnější a formálnější definice) je podáván přehled úrovní závislosti jednoho modulu na druhém. Následující zjednodušený seznam úrovní závislostí je seřazen od nejvyšší fromy závislosti po nejnižší:

\paragraph{Content coupling (nejvyšší forma závislosti)} Jeden modul modifikuje jiný modul nebo se spoléhá na vnitřní fungování jiného modulu (např. přístup k~lokálním datům jiného modulu). V~důsledku platí, že změní-li se způsob, kterým tento druhý modul produkuje data (umístění, typ, časování), povede to zcela jiste ke změnám v~závislém modulu.

\paragraph{Common coupling} Dva moduly sdílí stejná globální data (např. globální proměnnou), změna sdíleného globálního zdroje implikuje změny všech modulů, které je používají.

\paragraph{External coupling} Dva moduly sdílí externě definovaný (standardizovaný) datový formát, komunikační protokol nebo rozhraní zařízení.

\paragraph{Control coupling} Jeden modul kontroluje tok druhého tím, že mu posílá informaci o~tom, co má konat (např. předání \uv{to-do} příznaku).

\paragraph{Stamp data coupling} Jeden modul předává druhému modulu složenou datovou strukturu jako parametr. Ten ji používá pouze pro výpočty (nikoliv pro rozhodování řízení toku programu).

\paragraph{Scalar data coupling} Moduly sdílí data pomocí parametrů. Každý parametr je elementární datový typ a jedná se o~jediná data, která jsou sdílená (např. předávání celočíselné hodnoty funkci, která spočítá jeho druhou mocninu). Modul, kterému jsou předávány parametry, jich používá pouze k~výpočtu hodnoty a nikoliv pro rozhodování řízení toku programu.

\paragraph{Message coupling (nejnižší forma závislosti)} Moduly jsou provázané pouze pomocí posílání zpráv (message passing). Jedná se o~nejnižší úroveň závislosti. Moduly o~sobě navzájem nemusí mít žádnou znalost. Moduly nepoužívají vzájemně žádné předávání parametrů, nemají žádné sdílené reference na objekty nebo globální data.

\paragraph{Independent coupling/No coupling} Mezi moduly není žádná závislost. Moduly spolu vůbec nekomunikují a nejsou zde žádné sdílené reference na proměnné nebo reference na externí data sdílená mezi moduly.

\vspace{1cm}

Cílem návrhu je snižovat co nejvíce míru závislosti modulů. Protože se ale jedná o~kvantitativní záležitost, nejsme schopni určit zcela přesná pravidla, která musí platit nebo která lze vynutit. U~některých typů programů může být akceptovatelý i \emph{content coupling} z~výkonnostních důvodů\footnote{Nízká provázanost implikuje téměř vždy snížení výkonu z~důvodu nutnosti dalších mechanismů, které zprostředkovávájí komunikaci mezi moduly (např. \emph{message passing} mechanismus).}, naopak u~jiných systémů může být nízká provázanost (\emph{message coupling}) dána již návrhem (např. CORBA, web services, atd.).

%% TODO: přidat coupling v pojetí objektově orientovaného programování
%% TODO: zapracovat
% dedicnost (inheritance)
% vyvolání metody
% instanciace třídy

\subsubsection{High cohesion (vysoká koheze/soudržnost)}

% TODO: úrovně koheze -- koheze na úrovni metody, třídy, balíčku, modulu, projektu
% TODO: rozdělení metody pro lepší testovatelnost
Wikipedia \cite{wiki:cohesion}:
\begin{itemize}
\item míra, jak silně související je funkčnost vyjádřená zdrojovým kódem konkrétního modulu
\end{itemize}

Článek \cite{Kang:1996:DCM:872750.873361}:
\begin{itemize}
\item association-based approach (coincidental, logical, \ldots),
\item slice-based approach,
\item def-use paths,
\item velmi exaktní přístup.
\end{itemize}

Článek \cite{ISI:000079726000029} uvádí dělení koheze podle tzv SMC\footnote{Podle původních autorů Stevens, Myers a Constantine.} Cohesion:

\paragraph{Coincidental association} Neexistuje souvislost mezi elementy provádějícími zpracování.

\paragraph{Logical association} Oba elementy provádějící zpracování patří do stejné logické třídy příbuzných funkcí.

\paragraph{Temporal association} Každý výskyt obou elementů provadějících zpracování je v~tom samém omezeném časovém období při provádění programu.

\paragraph{Procedural association} Oba elementy provádějící zpracování jsou elementy stejné procedurální jednotky, která je iterativním nebo rozhodovacím procesem.

\paragraph{Communicational association} Oba elementy provádějící zpracování pracují nad stejnou množinou vstupních dat a/nebo produkují stejná výstupní data.

\paragraph{Sequential association} Výstupní data jednoho elementu jsou vstupními daty pro druhý element.

\paragraph{Functional association} Oba elementy jsou nezbytné pro provedení jedné funkce/operace.

\subsubsection{Law of Demeter}

%% **Demeter law:**
%% * [[Assuring Good Style for Object-Oriented Programs|http://portal.acm.org/citation.cfm?id=624870]]
%% * [[Adaptive Object-Oriented Software The Demeter Method|http://www.google.cz/url?sa=t&source=web&cd=3&sqi=2&ved=0CCoQFjAC&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.94.8349%26rep%3Drep1%26type%3Dpdf&rct=j&q=demeter%20software%20object%20oriented&ei=MeTOTPihHI7AswbpufiWCA&usg=AFQjCNHnRixmCYTZrJVPF2OCEcbooajq4A&cad=rja]]
%% * [[The Law of Demeter Is Not A Dot Counting Exercise|http://bit.ly/9tCObJ]] - pěkný popularizační článek na úvod
%% * [[Object-oriented programming: an objective sense of style|http://portal.acm.org/ft_gateway.cfm?id=62113&type=pdf&coll=GUIDE&dl=GUIDE&CFID=111192652&CFTOKEN=98650016]]
%% * [[Formulations and benefits of the law of demeter|http://portal.acm.org/citation.cfm?id=643603.643608]]
%% * [[Demeter: Aspect-Oriented Software Development|http://www.ccs.neu.edu/research/demeter/]]
%% * [[A case for statically executable advice: checking the law of demeter with AspectJ|http://portal.acm.org/citation.cfm?id=643603.643608]]

Existuje několik forem Demeterova zákona \cite{35588}, které jsou vhodné pro různé oblasti aplikace. Tyto typy jsou znázorněny na obrázku \ref{demeter_law_types}. V~\cite{35588} se též pojednává o~demeterově zákoně z~jiného úhlu -- uvažují se všechny možné třídy, které lze volat bez porušení tohto principu (tzv. preferred suppliers).

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\textwidth]{./graphs/demeter_law_types.png}
  \caption{Formy návrhového principu LoD.\label{demeter_law_types}}
\end{figure}

Pro statickou analýzu lze použít \uv{class} formu Demeterova zákona.

% TODO: rozhodnout, kterou verzi Demeterova zákona použít

\emph{Zjednodušená verze \cite{wiki:lod}}

Method M of an object O~may only invoke the methods of the following kinds of objects:

\begin{itemize}
\item O~itself,
\item M's parameters,
\item any objects created instantiated within M,
\item O's direct component objects,
\item a global variable, accessible by O~in the scope of M.
\end{itemize}

\subsection{Ukázky kódu porušujícího některá z~pravidel}
% TODO: v rámci každého návrhového principu uvést příklad porušení tohoto principu (případně i příklad, který tento princip dodržuje)

\subsubsection{Porušení principu law of Demeter}

% TODO: find some better (real world) example of demeter law violation on the web
\lstset{
  basicstyle=\ttfamily,
  numbers=left,
  numberstyle=\tiny,
  commentstyle=\color{gray}\textit
}
\begin{lstlisting}[language=java]
  package violations;

  public class DemeterLawViolation {

    void method(MyClass obj, int val) {

      obj.getSomeInternalField().setValue(val);

      // hidden violation:
      InternalFieldDef internalField =
      obj.getSomeInternalField();
      internalField.setValue(val);

    }

  }
\end{lstlisting}

\section{Analýza problematiky v~jazyce Java}

\subsection{Statický model programu v~Javě}
% TODO: pojednání o tom, co všechno může být modelem programu (ast, graf, FSM, programovací jazyky, atd)
% TODO: model driven engineering, kód je fyzický model, můžeme jej ale dále převádět na další modely a ty potom analyzovat
% TODO: možná přidat poznámku o model driven engineering a jak může být aplikováno právě zde

%% TODO: zapracovat do této sekce nebo smazat
%% # Model driven engineering
%% * [[A Taxonomy of Model Transformations|http://drops.dagstuhl.de/opus/volltexte/2005/11/pdf/04101.SWM2.Paper.pdf]] - článek přehledně shrnuje základní pojmy týkající se transformace modelů
%% # Architecture specific model
%% V následujícím článku je demonstrován převod architektonicky závislého modelu (konkrétně MVC) na dva různé platformně specifické modely (EJB a Spring beans). Pro definici PIM je vytvořen vlastní jednoduchý UML profil.
%% * [[Kazato H., Model-View-Controller Architecture Specific Model Transformation|http://www.dsmforum.org/events/DSM09/Papers/Kazato.pdf]]

\subsubsection{Struktura softwarového projektu v~Javě}

% TODO: sort and rephrase

\begin{itemize}
\item \verb+*.java+ soubory -- v~gramatice programovacího jazyka Java 1.5 představují top-level element CompilationUnit,
\item binární součásti projektu (např. knihovny) -- \verb+*.jar+ soubory, \verb+*.class+ soubory,
\item build scripty a konfigurační soubory sestavovacích nástrojů (\verb+build.xml+, \verb+pom.xml+, \ldots),
\item zdroje (resources, resource bundles),
\item dokumentace (\verb+javadoc+, \ldots),
\item soubory gramatik pro parsery (např. pro \verb+lex+, \verb+flex+, \verb+javacc+, \verb+antlr+, atd.),
\item šablony (typické třeba pro webové projekty, \verb+*.xhtml+ a jiné přípony),
\item konfigurační soubory (zpravidla \verb+*.xml+ soubory, často odkazují konkrétní třídy progamovacího jazyka Java),
\item jiné soubory
\end{itemize}

Pro naše potřeby jsou důležité v~podstatě pouze kompilační jednotky (\verb+*.java+ soubory) projektu.

%% TODO: přesunout na správné místo (možná patří až do návrhu)
Při analýze nebudeme uvažovat běh programu. Bude se jednat o statickou analýzu kódu. Práce bude probíhat nad definicemi tříd, nikoliv nad jejich instancemi v~paměti JVM. Nejsou tedy uvažovány všechny možné běhové instance programu (všechny možné stavy objektů v~paměti virtuálního stroje).

Projekt závisí na dalších třídách, které analyzovat nebudeme (v~určitém okamžiku analýzy je potřeba se \uv{odříznout}, jinak bychom mohli analyzovat všechny knihovny, s~nimiž projekt pracuje). Takové závislosti mohou být např.:

\begin{itemize}
\item knihovny třetích stran
\item standardní knihovna jazyka Java (např. Java 2 Platform SE 5.0 API pro Javu verze 5) -- zde například budou povoleny závislosti ze všech modulů (ale pro jiné druhy analýzy to může být nežádoucí - např. u~logování budeme chtít, aby v~projektu šlo striktně přes nějakou naši konkrétní \emph{fasádu})
\item podprojekty a části projektu, které analyzovat nechceme, nepotřebujeme nebo z~nějakého důvodu nemůžeme
\end{itemize}

% TODO: aktualizovat -> v konecnem dusledku budeme pracovat i nad projekty v jazyce 1.6 (protoze nam to rozhrani umoznuje)
Budeme pracovat nad gramatikou jazyka Java 1.5. Java verze 6 se liší pouze úpravou standardních API poskytovaných platformou Java. Jazyk jako takový zůstává stejný.

\subsubsection{Syntaktické elementy programovacího jazyka Java}
Grafické znázornění základních syntaktických elementů, jejichž struktura a názvy jsou převzaty z~\cite{Gosling:2005:JLS:1036643}, je na obrázku \ref{toplevel_elements}.
% TODO: write some better accompanying text
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{./graphs/java_top_elements.png}
  \caption{Struktura základních syntaktických elementů programovacího jazyka Java.\label{toplevel_elements}}
\end{figure}

Pro analýzu založenou na vyhledávání závislostí mezi třídami pro nás bude nejdůležitější syntaktický element \emph{TypeDeclaration}. Tento neterminální symbol se dále přepisuje na symboly uvedené na obrázku \ref{type_declaration_options}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{./graphs/toplevel_types.png}
  \caption{Rozklad elementu TypeDeclaration.\label{type_declaration_options}}
\end{figure}

\subsection{Existující nástroje pro zpracování zdrojových kódů v~jazyce Java}

% TODO: write some leading text

Možnosti zpracovávání kódu:

% TODO: roztřídit a vyházet nesmysly
% TODO: použít jinou vhodnější strukturu místo itemize (např. strukturovaný text)
\begin{itemize}
\item vlastní hand-written lexikální a syntaktický analyzátor (zbytečně náročné)
\item parser vygenerovaný pomocí některého z~dostupných compiler-compiler systémů
  \begin{itemize}
  \item tyto systémy na základě vstupní gramatiky vygenerují frontend pro překladač
  \item lze specifikovat různé akce, které jsou navázány na události vyvolané v~průběhu syntaktické analýzy
  \item \emph{JavaCC} \cite{parsertools:javacc}
    \begin{itemize}
    \item součástí je nástroj \emph{JJTree}, který je schopen vygenerovat AST pro další práci
    \end{itemize}
  \item \emph{JastAdd} \cite {parsertools:jastadd}
  \item \emph{JLex} \cite{parsertools:jlex}
    \begin{itemize}
    \item A~Lexical Analyzer Generator for Java(TM)
    \end{itemize}
  \item JFlex \cite{parsertools:jflex}
    \begin{itemize}
    \item The Fast Scanner Generator for Java
    \end{itemize}
  \end{itemize}
\item použití vhodné knihovny
  \begin{itemize}
  \item JavaParser \cite{parsertools:javaparser}
    \begin{itemize}
    \item projekt na GoogleHosting
    \item v~podstatě gramatika pro JJTree vytvářející strom tříd a objektů, který je možné procházet pomocí visitor patternu
    \end{itemize}
  \end{itemize}
\item použití prostředků platformy NetBeans \cite{parsertools:javasourcejavadoc}
  \begin{itemize}
  \item Java Source API
  \end{itemize}
\item použití prostředků poskytovaných platformou Java 6 (Sun verze) \cite{source_code_analysis_corejavatechtips}
  \begin{itemize}
  \item \emph{JSR 199 -- Java Compiler API}
    \begin{itemize}
    \item volání překladače jazyka Java pomocí API ze zdrojového kódu programu
    \item balíček \verb+javax.tools+
    \end{itemize}
  \item \emph{JSR 269 -- Pluggable Annotation Processing API}
    \begin{itemize}
    \item možnost přidání vlastního kódu pro zpracovávání anotací/kódu do instance překladače
    \item balíček \verb+javax.annotation.processing+ -- zpracovávání anotací
    \item balíček \verb+javax.lang.model+ -- třídy poskytující model pro syntaktické elementy jazyka Java
    \end{itemize}
  \item \emph{Compiler Tree API} \cite{parsertools:compilertreeapi}
    \begin{itemize}
    \item nestandardní rozšíření Java JDK
    \item balíček \verb+com.sun.source.tree+ -- poskytuje rozhraní pro reprezentaci zdrojového kódu jako AST
    \item balíček \verb+com.sun.source.util+ -- poskytuje rozhraní pro operace nad AST
    \end{itemize}
  \end{itemize}
\item použití prostředků, které jsou k~dispozici pro platformu Eclipse
  \begin{itemize}
  \item org.eclipse.jdt.core.dom package
  \item spoon \cite{parsertools:spoon}
  \end{itemize}
\end{itemize}

% TODO: zatřídit:
Důležité části zpracování kódu:
\begin{itemize}
\item name resolution, jmenné prostory (namespaces), class loaders, class tables
\item static methods
\item inner classes, static classes
\item polymorphism
\item generické třídy, wildcards
\item pole objektů
\item návratové typy metod
\item vstupní parametry metod
\item lokální proměnné
\item globální objekty (statické metody a pole tříd, singletony - opět ale pouze ze statického pohledu!)
\item vizualizace grafu
\item modifikátory přístupu (private, public, protected, package private) -- možnost \uv{ořezat} graf závislosti tříd -- je možné, že pro některé druhy analýzy bude toto nežádoucí.
\end{itemize}

% TODO: zatřídit || smazat
Úrovně na nichž je možné provádět validaci správného návrhu:
\begin{itemize}
\item design level -- analýza správného návrhu softwarového díla (pracuje se na konceptuální úrovni, ještě není hotový kód)
\item code level -- analýza existujícího kódu z~pohledu návrhu (již máme kód, ale chceme zpětně ověřit, že představuje dobrý/špatný návrh)
\end{itemize}

%% TODO: zapracovat || smazat
%% # Existující formalizace v softwarovém inženýrství

%% ## Z notation
%% * [[The Z notation - wikipedia|http://en.wikipedia.org/wiki/Z_notation]]
%% * [[ISO/IEC 13568:2002(E) - Information technology - Z formal specification notation — Syntax, type system and semantics|http://standards.iso.org/ittf/PubliclyAvailableStandards/c021573_ISO_IEC_13568_2002(E).zip]]
%% * [[Z notation reference manual|http://www.rose-hulman.edu/class/csse/cs415/zrm.pdf]]

%% # Featherweight Java
%% ## Výrazy jazyka FJ
%% FJ má pouze následující výrazy (expressions):
%% * vytvoření objektu (object creation)
%% * vyvolání metody (method invocation)
%% * přístup k poli objektu (field access)
%% * přetypování (casting)
%% * proměnné (variables)
%% FJ vynechává operátor přiřazení (s výjimkou konstruktorů).
%% Přes to všechno je FJ výpočetně kompletní (computationally complete) - je snadné do FJ zakódovat *lambda kalkul*.
%% Existuje přímá souvislost mezi FJ a programovacím jazykem Java. Každý FJ program je spustitelný Java program.
%% ## FJ program
%% FJ program sestává ze souboru *několika tříd* a *výrazu*, který je vyhodnocen. Tento výraz odpovídá *main* metodě v plné verzi programovacího jazyka Java.
%% Třídy sestávají z konstruktoru (který se vypisuje vždy) a z jednotlivých metod.
%% Každá metoda vždy obsahuje pouze klíčové slovo *return* následované výrazem, který je vyhodnocen. Ve FJ totiž nejsou možné operace s vedlejším efektem (side-effect) vzhledem k absenci operátoru přiřazení. Vlastně se jedná o "funkcionální" část jazyka Java.
%% ## Možná uváznutí programu
%% * pokus o příštup k poli, které není pro třídu nadefinované
%% * pokus o vyvolání metody, která není pro třídu nadefinovaná
%% * pokus o přetypování na něco jiného než je nadtřídou běhové třídy objektu
%% V dobře typovaných programovacích jazycích by k něčemu takovému němělo dojít (to je cílem důkazu poskytovaného FJ).
%% ## Nástroje
%% * [[FJ-Eclipse|http://fj-eclipse.sourceforge.net/]] - nepodporuje všechny prvky jazyka (např. vyhodnotí volání konstruktoru nadtřídy super() jako chybu)
%% ## Literatura
%% * [[Atsushi Igarashi, Benjamin C. Pierce, and Philip Wadler. 2001. Featherweight Java: a minimal core calculus for Java and GJ. ACM Trans. Program. Lang. Syst. 23, 3 (May 2001), 396-450. DOI=10.1145/503502.503505 http://doi.acm.org/10.1145/503502.503505|http://portal.acm.org/citation.cfm?id=503505]]
%% * [[http://klee.cs.depaul.edu/csc547/lecture-fj.html]]

%% # Klíčová slova, související pojmy
%% Zde jsou soustředěny pojmy které ať už přímo nebo nepřímo souvisí s naší cílovou oblastí výzkumu. Většinou se jedná o pojmy, které je vhodné použít pro rešerše v internetových vyhledávačích.
%% * design patterns discovery
%% * model transformation
%% * [[formal methods|http://en.wikipedia.org/wiki/Formal_methods]]
%% * [[formal specification|http://en.wikipedia.org/wiki/Formal_specification]]
%% * [[formal verification|http://en.wikipedia.org/wiki/Formal_verification]]
%% * model verification

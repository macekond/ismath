\chapter{Návrh}

TODO: zmínky o konkrétních pravidlech (demeter law atd) přesunout až do implementace, zde se zabývat pouze tím, jak budou pravidla vypadat obecně

\section{Návrh způsobu specifikace pravidel}

Abychom mohli specifikovat pravidla, musíme nejprve definovat strukturu, nad kterou budou tato pravidla platit. V tomto textu formalizujeme model programu pomocí teorie grafů. Nad grafem je možné dále specifikovat pravidla, která musí vstupní projekt splňovat.

\subsection{Formalizace modelu programu pomocí grafu}
\label{design-graph_formalization}

\emph{TODO:} (zapracovat nebo smazat): definice mapování zdrojových kódů na graf (zobrazení, které vybraným elementům AST přiřadí množinu vrcholů $V$ grafu $G$)

Analyzovaný softwarový projekt abstrahujeme jako orientovaný multigraf rozšířený o zobrazení množiny uzlů do množiny typů a zobrazení hran do množiny jejich klasifikátorů (označení typu vztahu mezi uzly). Dále přidáme ke každému vrcholu zobrazení, které mu přiřadí jméno (řetězec). Získáme tak následující strukturu:

\begin{displaymath}
  G = \langle V, E, \rho, K, C, N, \mathit{Kind}, \mathit{Class}, \mathit{Name}\rangle
  \label{extended_multigraph}
\end{displaymath}
v níž platí:
\begin{itemize}
\item $V$ je množina elementů (v našem případě části kódu)
\item $E$ je množina hran (v našem případě vztahy mezi částmi kódu - např. volání funkce, dědičnost)
\item $V \cap E = \emptyset$
\item $\rho: E \mapsto V \times V$ je zobrazení množiny hran do množiny uspořádaných dvojic vrcholů (incidence)
\item $K$ je libovolná množina označení typů vrcholů\footnote{Pod pojmem typ zde rozumíme jakékoliv označení, které specifikuje o jaký objekt se jedná -- může to být třída, metoda, příkaz, \ldots},
\item $\mathit{Kind}: V \mapsto K$ je zobrazení, které přiřadí každému vrcholu jeho typ,
\item $C$ je množina klasifikátorů hran,
\item $N$ je množina jmen (řetězců)
\item $\mathit{Class}: E \mapsto C$ je zobrazení, které přiřadí každé hraně její klasifikátor (zda se jedná o \emph{method call}, \emph{dědičnost}, atd.)
\item $\mathit{Name}: V \mapsto N$ je zobrazení, které přiřadí vrcholu jeho jméno (např. jméno třídy, jméno metody, \ldots)
\end{itemize}

Ukázka formalizace zdrojového kódu pomocí grafu je na obrázku \ref{design-graph_example}. V uvedeném příkladě můžeme strukturu $G$ namapovat následujícím způsobem:
\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\textwidth]{./graphs/graph_example.png}
  \caption{Příklad formalizace hierarchie tříd jako grafu.\label{design-graph_example}}
\end{figure}
Množinu vrcholů můžeme ztotožnit s množinou názvů elementů (v našem případě třídy, pole, metody)\footnote{V konečném důsledku bude tato množina představována konkrétními elementy tak, jak se nalézají ve zdrojovém kódu.}.
\begin{align*}
  V = &\{ \\
  &Vehicle, Car, MotorCycle, Bicycle, MountainBike, RacingBike, \\
  &wheelNumber, doorNumber, \\
  &controlGear, gearUp, gearDown \\
  &\}
\end{align*}
Abychom mohli demonstrovat množinu hran, bylo provedeno očíslování. Hranu zde identifikujeme číslem. V počítačové reprezentaci se může jednat o konkrétní objekt uložený v poli. Množinu hran potom můžeme reprezentovat prostým výčtem čísel:
\begin{displaymath}
  E = \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\}
\end{displaymath}
Zobrazení $\rho$ můžeme formálně zapsat jako následující množinu\footnote{Zobrazení je binární relace. Proto jej můžeme reprezentovat jako množinu uspořádaných dvojic.}:
\begin{align*}
  \rho = &\{ \\
  &(1, (Bicycle, Vehicle)), \\
  &(2, (Car, Vehicle)), \\
  &(3, (MotorCycle, Vehicle)), \\
  &(4, (MountainBike, Bicycle)), \\
  &(5, (RacingBike, Bicycle)), \\
  &(6, (Vehicle, wheelNumber)), \\
  &(7, (Car, gearUp)), \\
  &(8, Car, controlGear)), \\
  &(9, (Car, doorNumber)), \\
  &(10, (Car, gearDown)), \\
  &(11, (controlGear, gearUp)), \\
  &(12, (controlGear, gearDown)) \\
  &\}
\end{align*}
Zbývají nám množina typů $K$,
\begin{align*}
  K = \{ class, public\_field, public\_method \}
\end{align*}
množina klasifikátorů hran $C$,
\begin{align*}
  C = \{ \langle\langle{}extends\rangle\rangle, \langle\langle{}has\_member\rangle\rangle, \langle\langle{}calls\rangle\rangle \}
\end{align*}
přiřazení typů uzlům $Kind$,
\begin{align*}
  Kind = &\{ \\
  &(Bicycle, class), \\
  &(Car, class), \\
  &(MotorCycle, class), \\
  &(MountainBike, class), \\
  &(RacingBike, class), \\
  &(Vehicle, class), \\
  &(wheelNumber, public\_field), \\
  &(doorNumber, public\_field), \\
  &(controlGear, public\_method), \\
  &(gearUp, public\_method), \\
  &(gearDown, public\_method) \\
  &\}
\end{align*}
a přiřazení klasifikátorů hranám:
\begin{align*}
  Class = &\{ \\
  &(1, \langle\langle{}extends\rangle\rangle), \\
  &(2, \langle\langle{}extends\rangle\rangle), \\
  &(3, \langle\langle{}extends\rangle\rangle), \\
  &(4, \langle\langle{}extends\rangle\rangle), \\
  &(5, \langle\langle{}extends\rangle\rangle), \\
  &(6, \langle\langle{}has\_member\rangle\rangle), \\
  &(7, \langle\langle{}has\_member\rangle\rangle), \\
  &(8, \langle\langle{}has\_member\rangle\rangle), \\
  &(9, \langle\langle{}has\_memeber\rangle\rangle), \\
  &(10, \langle\langle{}has\_member\rangle\rangle), \\
  &(11, \langle\langle{}calls\rangle\rangle), \\
  &(12, \langle\langle{}calls\rangle\rangle), \\
  \}
\end{align*}

%% Graf elementů použitých v kódu. Vrcholy $v \in V$ představují různé syntaktické elementy v analyzovaném kódu. Záleží na úrovni prováděné analýzy, jaké zvolíme vrcholy. V případě, že budeme analyzovat \uv{nízkoúrovňové} chování funkce, mohou být vrcholy jednotlivé příkazy a jejich části. Pokud budeme analyzovat míru provázanosti tříd nebo metod, stačí když použijeme jako vrcholy třídy a metody (případně parametry metod.)
%% $G = (V, E)$

\subsection{Formalizace pravidel}

\begin{itemize}
\item definice jazyka pro specifikaci pravidel
\item specifikovat množinu objektů, nad nimiž budou pravidla stavěna -- nad čím budeme operovat (možnosti: gramatika, třídy, FJ, graf, \ldots)
\item lze vyjít z Java Language Specification (množina neterminálních a terminálních symbolů)
\item může být nějaký DSL
\end{itemize}

\subsection{Typy pravidel}
\begin{itemize}
\item pravidla definovaná ve vytvořeném formalismu (DSL rules)
\item uživatelsky programovaná pravidla (custom code java code, asserts)
\end{itemize}

TODO: zapracovat:

Ne všechna pravidla lze popsat exaktně ve smyslu splněno/nesplněno. Mnohdy můžeme kvalitu návrhu posuzovat pouze kvantitativně (dobrý návrh, lepší, moc vazeb, málo vazeb, atd.). Pro některé vlastnosti návrhu (např. low coupling, high cohesion) může být vhodnější poskytnou statistický přístup pro vyhodnocování (např. použití vhodného klasifikátoru).

\section{Návrh architektury systému}
\label{design-architecture}
%TODO: highlevel design $\rightarrow$ jaké budou moduly a co budou dělat (zatím bez konkrétní použité technologie)
TODO: odstavec o modulech systému, pro každou část/modul napsat samostatnou podsekci, která popíše, jaké třídy modul obsahuje a jaké jsou jejich zodpovědnosti (responsibilities)
% NOTE: při zpracování většího projektu bude nejspíš nutné zavést nad jmény objektů vhodnou formu indexace pro zrychlení algoritmů (kanonická jména tříd jsou v javě poměrně dost dlouhá)


\begin{itemize}
\item compiler
\item generátor vnitřní struktury (modelu) -- modelem je v našem případě graf
  \begin{itemize}
  \item \emph{vstup:} množina cest k \verb+*.java+ souborům (kompilačním jednotkám), z nichž se skládá softwarový projekt
  \item \emph{výstup:} graf, reprezentující konkrétní analyzovanou doménu vhodný pro další zpracování (graf podle \ref{design-graph_formalization} \nameref{design-graph_formalization})
  \end{itemize}
\item možnosti generování grafu závislostí mezi třídami (vnitřní reprezentace):
  \begin{itemize}
  \item on demand -- když bude potřeba, vybuduje se kompletně celý graf a poté se zahodí
  \item on the fly -- při práci uživatele na kódu se bude vždy generovat znovu celý graf
  \item kombinovaný přístup -- graf se ve vhodných okamžicích celý vybuduje a poté budou probíhat jeho následné aktualizace na základě uživatelovy práce nad kódem
  \end{itemize}
\item analyzátor
\item rozhraní - integrace do platformy NetBeans
  \begin{itemize}
  \item rozhraní pro zadávání pravidel
  \item rozhraní pro ověřování platnosti pravidel (validaci)
  \end{itemize}
\end{itemize}

Návrh highlevel struktury je na obrázku \ref{design-modules}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\textwidth]{./uml/archval_module_cmp.png}
  \caption{Rozdělení systému na samostatné komponenty.\label{design-modules}}
\end{figure}

Je potřeba definovat je dostatečně obecně -- interfaces (možnost oddědění vlastního rozšiřujícího rozhraní).

\begin{itemize}
\item \emph{Graph} (class)
\item \emph{Vertex} (class)
\item \emph{Edge} (class)
\end{itemize}

\begin{itemize}
\item \emph{av-core} - jádro systému
\item \emph{av-graphgen-demeter} -- ukázkový poskytovatel generátoru grafu
\item \emph{av-operators-demeter} -- ukázkový balíček operátorů pro ověřování principu LoD
\item \emph{av-reportgen-plaintext} -- ukázkový poskytovatel pro generování validačních reportů v~prostém textu
\end{itemize}

\subsection{Modul av-core}
TODO: popis validačního procesu: rozepsat
\begin{itemize}
\item systém načte moduly
\item systém zkontroluje základní předpoklady - existuje alespoň jeden modul pro generování grafu, alespoň jeden modul operátorů (nebo poskytovatel analyzerů ???) a alespoň jeden modul s poskytovatelem generátou výstupu
\item systém zparsuje soubor pravidel a vygeneruje AST
\item systém zkontroluje, zda pro AST pravidel existují potřebné providery grafů
\item systém zkontroluje, zda pro AST pravidel existují všechny operátory
\item systém provede nabindování operátoru na uzly AST pravidel
\item systém vygeneruje pro projekt všechny požadované grafy
\item systém vyhodnotí AST nad grafy pomocí operátorů, zjištěná porušení pravidel bude zapisovat do validačního reportu
\item systém projde všechny analyzátory a nechá je vygenerovat analyzační report
\item systém pomocí výstupních modulů vygeneruje reporty (na základě konfigurace ???)
\end{itemize}

Jádro systému bude poskytovat třídy a rozhraní popsané v tabulce \ref{design-archval_core_components}.

\begin{table}
\caption{Tabulka komponent jádra systému. \label{design-archval_core_components}}
\begin{center}
  \begin{tabular}{| l | l | p{8cm} | }
    \hline
    \textbf{Název} & \textbf{Typ} & \textbf{Zodpovědnost} \\
    \hline
    \hline
    Action & class & integrace s běhovou platformou, vstupní/aktivační bod systému \\ \hline
    ValidationTask & class & řízení procesu validace \\ \hline
    Validator & class & bude provádět validaci pravidel v grafu na základě vstupních pravidel \\ \hline
    Analyzer & class & bude provádět statistické analýzy (pro návrhové principy, které nelze popsat přesnými pravidly) \\ \hline
    ConfigurationManager & class & komponenta zprostředkující konfigurační uživatelské volby jádru programu \\ \hline
    GraphGeneratorManager & class & zinicializuje jednotlivé moduly pro generování grafů a použije je pro vygenerování grafů (pokud budou tyto grafy potřeba) \\ \hline
    ReportGeneratorManager & class & použije některé z dostupných poskytovatelů pro generování výstupu pro vygenerování reportu \\ \hline
    GraphGeneratorIface & interface & rozhraní, které musí implementovat poskytoval generátoru grafu \\ \hline
    OperatorIface & interface & rozhraní, které musí implementovat poskytovatel balíčku operátorů \\ \hline
    ReportGeneratorIface & interface & rozhraní, které musí implementovat poskystovatel modulu pro generování výstupních reportů \\ \hline
    AnalysisIface & interface & rozhraní, které musí implementovat poskytovatel analýzy nad některým z grafů \\ \hline
    GraphGeneratorRegister & class & třída poskytující přístup k informacím o existujících poskytovatelích generátorů grafu \\ \hline
    OperatorRegister & class & třída poskytující přístup k informacím o existujících poskytovatelích operátorů \\ \hline
    AnalysesRegister & class & třída poskytující přístup k informacím o existujících poskytovatelích komponent analýzy \\ \hline
    ReportGeneratorRegister & class & třída poskytující přístup k informacím o existujících poskytovatelích generátorů výstupních reportů \\ \hline
  \end{tabular}
\end{center}

\end{table}
Na obrázku \ref{design-archval_core} jsou zobrazeny komponenty modulu \emph{archval-core}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\textwidth]{./uml/archval_core_cmp.png}
  \caption{Komponenty jádra systému ArchVal.\label{design-archval_core}}
\end{figure}

\subsubsection{Action}
Integrace do běhové platformy. Reprezentuje uživatelskou akci. Bude implementováno na základě zvolené implementační platformy (akce v GUI).

\subsubsection{Controller}
Samostatné vlákno s řízením celého validačního procesu. Synchronized sekce. Vstupem bude vhodná specifikace umístění analyzovaného projektu.

TODO: vyladit následující interface
\begin{itemize}
\item setProject()
\item startValidationThread()
\item cancelValidationThread()
\item getReport()
\end{itemize}

\subsubsection{Validator}
Vstupem bude soubor pravidel

\begin{itemize}
\item registerOperatorPackage()
\item performValidation() : ValidationReport
\end{itemize}

Výstupem bude ValidationReport (vnitřní struktura, která se bude posléze převádět na vhodnou vnější reprezentaci).

\subsubsection{Analyzer}
TODO: analyzer providers ??? - analyzer nejspíš dostane k dispozici graf (opět musí specifikovat nad jakým grafem pracuje) a výstupem bude AnalysisReport (TBD!)

\subsubsection{GraphGeneratorManager}
Bude řídit přístup k jednotlivým graph generatorům. Umožní externím providerům registraci nových graph generátorů. Každý graph generátor (resp. graf) musí mít specifikované jedinečné id grafu. (To bude dále použito např. při specifikaci pravidel, kde je potřeba sdělit validátoru, nad kterým grafem má pravidlo platit).
\begin{itemize}
\item registerGraphGenerator()
\item getGraphGeneratorIds()
\item generateGraph(projectSpec, graphTypeId) : Graph
\end{itemize}

\subsubsection{ReportGeneratorManager}
Umožní registraci poskytovatelů modulů pro výstup.

\subsubsection{GraphGeneratorIface}
\subsubsection{OperatorPackageIface}
\subsubsection{ReportGeneratorIface}
Podpora pro různé formáty výstupu. Popsat vnitřní reprezentaci reportu, tak aby jej bylo možné převést na vhodnou vnější reprezentaci. Podpora pro dopsání různých výstupních formátu jako např.:
\begin{itemize}
\item HTML
\item prostý text
\item zobrazení pomocí swing komponent (vygenerování modelu pro JTree)
\item \ldots
\end{itemize}


\subsection{Modul av-graphgen-demeter}

Vstupem bude Java projekt

Výstupem bude Graf

TODO: nejprve navrhnout reprezentaci doménových objektů

\subsubsection{DemeterGraphGeneratorProvider}

\subsection{Modul av-operators-demeter}
\subsubsection{DemeterOperatorProvider}

\subsection{Modul av-reportgen-plaintext}
\subsubsection{PlaintextReportGeneratorProvider}

% TODO: navrhnout aplikaci tak, aby mela vice rozhrani (nejen GUI, ale i moznost integrace, moznost textoveho vstupu pravidel)

\section{Návrh rozhraní pro zadávání pravidel}
TODO: zapracovat: U každého pravidla musí být deklarace typu grafu, nad nímž má platit.
%% rozhraní pro zadávání pravidel bude dáno jazykem, který se pro definici pravidel bude používat - možná kompilátor DSL jazyka, výrazy, atd.
\begin{itemize}
\item rozhraní pro zadávání pravidel
\item formát zadávání pravidel (serializace formalismu tak, aby jej bylo možné textově nebo jinak zadávat)
\end{itemize}

\section{Návrh rozhraní pro ověřování platnosti pravidel (validaci)}
\begin{itemize}
\item výstupní rozhraní
\item validační události
\end{itemize}
% TODO: navrhnout formát výstupu

%% TODO:
% typy grafů: class hierarchy graph, call graph
% call graph: wikipedia (<<invokes>> vazby)
%
% http://en.wikipedia.org/wiki/Call_graph
%

%% TODO: dat na spravne misto
\section{Návrh technologií pro implementaci}
\begin{itemize}
\item NetBeans platform
\item Maven project
\item Java 1.6
\item vstupem bude java maven projekt
\item \ldots
  % TODO: vytvorit prehled technologii i s jejich popisy
\end{itemize}

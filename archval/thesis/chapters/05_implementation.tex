\chapter{Implementace}
% TODO: napsat přehled, co bude v této kapitole

% TODO: použít nebo smazat (případně zařadit jinam)
% TODO: moduly popsané v části \ref{design-architecture} implementujeme jako jednotlivé moduly platformy NetBeans.

\section{Specifikace pravidel požadovaných zadáním práce}
Pro specifikaci Demeter law definujeme predikát, který nám umožní vybrat vhodné množiny vrcholů. Vybrané množiny potom ověřeíme pomocí predikátu, který uřčí, zda jsou tyto množiny v~pořádku, či zda porušují \emph{LoD} princip.

\begin{definition}
Mějme graf $G = \langle V, E, \rho, K, C, N, \mathit{Kind}, \mathit{Classifier}, \mathit{Name}\rangle$ se zobrazeními definovanými dříve. Definujme selektor vrcholů $F(G, v', k', c')$, $v' \in V$, $k' \in K$, $c' \in C$ jako množinu vrcholů grafu $G$, které jsou dostupné z~vrcholu $v'$ pomocí orientované cesty, pro jejíž všechny vrcholy $v''$ s~výjimkou posledního platí $Kind(v) \ne k'$ a která obsahuje hranu $e$, pro niž platí $Classifier(e) = c' $.
\end{definition}

\subsection{Law of Demeter}
Pro provedení validace princip LoD využijeme graf podobný tomu na obrázku \ref{implementation-lod_graph}. Lze jej získat ze zdrojových kódů pogramu. Vazba $``uses"$ představuje všechna použití (přístup k~\emph{public} a \emph{protected} polím a \emph{volání metod}) jiných tříd v~rámci metody.

\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\textwidth]{./graphs/demeter_graph.png}
  \caption{Graf použitý pro validaci principu LoD.\label{implementation-lod_graph}}
\end{figure}

Pravidlo LoD potom specifikujeme následovně:

\begin{designprinciple}
Mějme grafový model projektu $G = \langle V, E, \rho, K, C, \mathit{Kind}, \mathit{Classifier}\rangle$. Návrhový princip LoD splňuje graf, pro který platí:

\begin{align*}
\forall v \in V: Kind(v) = ``method"\\
\end{align*}
\begin{align*}
&F(v, ``method", ``use") \setminus ( F(v, ``method", ``self") \cup F(v, ``method", ``field") \cup \\
&F(v, ``method", ``arg") \cup F(v, ``method", ``constr")) = \emptyset
\end{align*}

\end{designprinciple}

Specifikované pravidlo vyjadřuje požadavek, aby množina vrcholů do níž se dostaneme pomocí hran, které představují povolené vstupy tříd do analyzované třídy (třídní proměnné, parametry, vytvářené objekty), byla totožná s~množinou všech vrcholů, které představují všechny třídy používané (klasifikátor $``uses"$) v~rámci některé z~metod. Odečtení vrcholu $v$ z~výsledné množiny je zde kvůli tomu, abychom nemuseli navíc zavádět zbytečnou hranu identifikující, že třída je známá sama sobě.

\subsection{Low coupling, high cohesion}
% TODO:
% odkázat na rešeši v analýze a přidat poznámku o tom, že tato pravidla nebyla specifikována s tím, že je možné je realizovat jako analýzu pomocí rozhraní AnalysisIface

\section{Implementace jádra systému (modul av-core)}

\subsection{Implementace základních operátorů}
Vyhodnocení univerzálního kvantifikátoru $\forall v \in V$ lze přepsat jako jednoduchý cyklus přes vrcholy vrácené zpřesňující operátorem, která vybírá nějakou podmnožinu z~množiny vrcholů analyzovaného grafu. Získáme tak kód podobný listingu \ref{listing-forall}. V~tomto kódu, který je fragmentem metody, používáme symoblický název \verb+condition+ pro podmínku, kterou musí splňovat každý prvek \emph{v} iterované kolekce vrcholů \emph{vertices}.

\begin{lstlisting}[
    language=java,
    caption={Implementace univerzálního kvantifikátoru $\forall$.},
    label=listing-forall
  ]
for (Vertex v : vertices) {
    if (!condition(v, ...)) {
        return false;
    }
}
return true;
\end{lstlisting}

Analogicky budeme postupovat u~existenčního kvantifikátoru $\exists$. Zde nám stačí nalézt alespoň jeden element, pro který vyhodnocovaná vlastnost platí. Listing \ref{listing-exists} představuje fragment metody. Pokud se podaří nalézt alespoň jeden prvek, který splňuje požadovanou podmínku, metoda vrátí hodnotu \emph{true}. Vzhledem k~použití příkazu \emph{return} je zřejmé, že dochází k~\uv{línemu} vyhodnocování -- vyhodnocení je ukončeno nalezením prvního vyhovujícího elementu (další se neprohledávají). Stejně jako u~operátoru $\forall$ i zde název \verb+condition+ symbolizuje konkrétní podmínku, která má platit nad alespoň jedním prvkem množiny uzlů.

\begin{lstlisting}[
    language=java,
    caption={Implementace existenčního kvantifikátoru $\exists$.},
    label=listing-exists
  ]
for (Vertex v : vertices) {
    if (condition(v, ...)) {
        return true;
    }
}
return false;
\end{lstlisting}

Můžeme si všimnout, že se obě implementace liší pouze přehozením podmínek -- zatímco v~prvním případě ($\forall$) musíme projít všechny prvky, abychom zjistili, zda všechny prvky splňují požadovanou vlastnost, ve druhém případě ($\exists$) budeme všechny prvky procházet pouze v~krajním případě, kdy vlastnost neplatí pro žádný z~prvků.

\section{Integrace do NetBeans IDE (modul av-platform-integration)}

Při implementaci bylo hojně využíváno informací z~\cite{netbeans_platform}.

% TODO: write about actions, about usage of the ArchVal API
Seznam integračních komponent je k~dispozici v~tabulce \ref{implementation-integration_components}.

\begin{table}
  \caption{Tabulka integračních komponent systému. \label{implementation-integration_components}}
  \begin{center}
    \begin{tabular}{ | l | l | p{8cm} | }
      \hline
      \textbf{Název} & \textbf{Typ} & \textbf{Zodpovědnost} \\
      \hline
      \hline
      ValidateMainProject & class & integrace s~běhovou platformou, vstupní/aktivační bod \\ \hline
      %% TODO: 'třída implementující rozhraní...'
      GraphGeneratorRegister & class & třída poskytující přístup k~informacím o~existujících poskytovatelích generátorů grafu \\ \hline
      OperatorRegister & class & třída poskytující přístup k~informacím o~existujících poskytovatelích operátorů \\ \hline
      AnalysesRegister & class & třída poskytující přístup k~informacím o~existujících poskytovatelích komponent analýzy \\ \hline
    \end{tabular}
  \end{center}
\end{table}

\subsection{Implementace registrů poskytovatelů služeb}
\begin{itemize}
\item SPI
\item NetBeans lookup -- /META-INF/services
\end{itemize}

\subsection{Přidání uživatelské akce do nabídky prostředí}
Třída \emph{ValidateMainProject}

Integrace do běhové platformy. Reprezentuje uživatelskou akci. Bude implementováno na základě zvolené implementační platformy (akce v~GUI).

\subsection{Vstupní rozhraní}
% TODO: reorder to fit right order
\subsubsection{Ukázka vstupního formátu}
\lstinputlisting[
  label=avdgrammar,
  caption={Ukázka vstupního AVD souboru.}
]{./listings/example.avd}

\subsubsection{Podpora editace AVD souborů}
\begin{itemize}
\item experimentální mime typ \verb+text/x-avd+
\item zvýrazňování syntaxe (modul av-avd-highlighter)
\end{itemize}

\subsection{Výstupní rozhraní}
% TODO: zde popsat implementované výstupní rozhraní (alternativy by měly být diskutovány v návrhu)
% TODO: textový výstup

\section{Implementace modulů rozšíření}

% TODO: rozepsat
\begin{itemize}
\item SPI -- implementace rozhraní
\item pojem \emph{poskytovatel služby}
\item lookup, META-INF/services, registrace služeb
\end{itemize}

\subsection{Modul av-graphgen-demeter}
ukázkový poskytovatel generátoru grafu

\emph{DemeterGraphGeneratorProvider} implementuje \emph{GraphGeneratorIface}.

\subsection{Modul av-operators-demeter}
ukázkový balíček operátorů pro ověřování principu LoD

Obsahuje sadu tříd implementující operátory potřebné pro definování pravidla pro validaci LoD. Tyto třídy implementují rozhraní \emph{OperatorIface} (resp. jeho podtypy).
